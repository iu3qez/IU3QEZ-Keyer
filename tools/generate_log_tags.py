#!/usr/bin/env python3
"""
Generate a list of all logging tags from the codebase.

This script scans all .cpp and .hpp files in the components/ directory,
extracts logging tag definitions, and generates a C++ header file with
the list of known tags.

Usage:
    python3 generate_log_tags.py <components_dir> <output_header>

Example:
    python3 generate_log_tags.py components/ components/ui/include/ui/generated_log_tags.hpp
"""

import re
import sys
from pathlib import Path
from typing import Set


def extract_log_tags(file_path: Path) -> Set[str]:
    """
    Extract logging tags from a single source file.

    Looks for patterns like:
    - static const char* TAG = "TagName";
    - const char* TAG = "TagName";
    - constexpr const char* kLogTag = "TagName";
    - static constexpr const char kLogTag[] = "TagName";
    - constexpr char kLogTag[] = "TagName";

    Returns:
        Set of tag names found in the file
    """
    tags = set()

    # Patterns to match tag definitions (with and without 'const')
    # Match TAG or kLogTag with various modifiers (static, constexpr, const)
    # Both pointer and array syntax
    patterns = [
        # TAG patterns
        r'(?:static\s+)?(?:constexpr\s+)?(?:const\s+)?char\s*\*\s+TAG\s*=\s*"([^"]+)"',
        r'(?:static\s+)?(?:constexpr\s+)?(?:const\s+)?char\s+TAG\[\]\s*=\s*"([^"]+)"',
        # kLogTag patterns
        r'(?:static\s+)?(?:constexpr\s+)?(?:const\s+)?char\s*\*\s+kLogTag\s*=\s*"([^"]+)"',
        r'(?:static\s+)?(?:constexpr\s+)?(?:const\s+)?char\s+kLogTag\[\]\s*=\s*"([^"]+)"',
    ]

    try:
        content = file_path.read_text(encoding='utf-8', errors='ignore')

        for pattern in patterns:
            matches = re.findall(pattern, content)
            tags.update(matches)

    except Exception as e:
        print(f"Warning: Failed to read {file_path}: {e}", file=sys.stderr)

    return tags


def scan_components_directory(components_dir: Path) -> Set[str]:
    """
    Recursively scan components directory for all logging tags.

    Args:
        components_dir: Path to components/ directory

    Returns:
        Set of all unique tag names found
    """
    all_tags = set()

    # Scan all .cpp and .hpp files
    for pattern in ['**/*.cpp', '**/*.hpp']:
        for file_path in components_dir.glob(pattern):
            tags = extract_log_tags(file_path)
            all_tags.update(tags)

    return all_tags


def generate_header(tags: Set[str], output_path: Path) -> None:
    """
    Generate C++ header file with the list of tags.

    Args:
        tags: Set of tag names
        output_path: Path to output header file
    """
    sorted_tags = sorted(tags)  # Sort alphabetically for consistency

    header_content = f"""/**
 * @file generated_log_tags.hpp
 * @brief Auto-generated list of logging tags
 *
 * This file is automatically generated by tools/generate_log_tags.py
 * during the build process. DO NOT EDIT MANUALLY.
 *
 * To regenerate, run: cmake --build build
 */

#pragma once

#include <cstddef>

namespace ui {{

// Auto-generated list of all known logging tags in the codebase
static const char* KNOWN_LOG_TAGS[] = {{
"""

    # Add each tag
    for tag in sorted_tags:
        header_content += f'    "{tag}",\n'

    header_content += f"""
}};

static constexpr size_t KNOWN_LOG_TAGS_COUNT = sizeof(KNOWN_LOG_TAGS) / sizeof(KNOWN_LOG_TAGS[0]);

}}  // namespace ui
"""

    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Write header file
    output_path.write_text(header_content, encoding='utf-8')

    print(f"Generated {output_path} with {len(sorted_tags)} tags")
    for tag in sorted_tags:
        print(f"  - {tag}")


def main():
    if len(sys.argv) != 3:
        print("Usage: generate_log_tags.py <components_dir> <output_header>", file=sys.stderr)
        print("Example: generate_log_tags.py components/ components/ui/include/ui/generated_log_tags.hpp", file=sys.stderr)
        sys.exit(1)

    components_dir = Path(sys.argv[1])
    output_header = Path(sys.argv[2])

    if not components_dir.is_dir():
        print(f"Error: {components_dir} is not a directory", file=sys.stderr)
        sys.exit(1)

    print(f"Scanning {components_dir} for logging tags...")
    tags = scan_components_directory(components_dir)

    if not tags:
        print("Warning: No logging tags found!", file=sys.stderr)

    generate_header(tags, output_header)
    print(f"Successfully generated {output_header}")


if __name__ == '__main__':
    main()
