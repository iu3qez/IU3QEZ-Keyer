#include "config/parameter_registry.hpp"
#include "config/parameter_table.hpp"  // Task 3.7: For PARAMETER_TABLE macro

#include <algorithm>
#include <array>
#include <cctype>
#include <cstring>

extern "C" {
#include "cJSON.h"
}

extern "C" {
#include "esp_log.h"
}

namespace config {

namespace {
const char* TAG = "param_registry";
}  // namespace

//
// ParameterRegistry implementation
//

void ParameterRegistry::Register(std::unique_ptr<Parameter> param) {
  if (!param) {
    ESP_LOGW(TAG, "Attempted to register null parameter");
    return;
  }

  // Check for duplicate registration
  const char* name = param->GetName();
  for (const auto& existing : parameters_) {
    if (strcmp(existing->GetName(), name) == 0) {
      ESP_LOGW(TAG, "Parameter '%s' already registered, skipping duplicate", name);
      return;
    }
  }

  ESP_LOGD(TAG, "Registered parameter: %s (%s)", name, param->GetTypeName());
  parameters_.push_back(std::move(param));
}

Parameter* ParameterRegistry::Find(const char* name) const {
  for (const auto& param : parameters_) {
    if (strcmp(param->GetName(), name) == 0) {
      return param.get();
    }
  }
  return nullptr;
}

std::vector<Parameter*> ParameterRegistry::GetVisibleParameters(
    const char* subsystem_prefix, const DeviceConfig& config) const {
  std::vector<Parameter*> visible;
  const size_t prefix_len = strlen(subsystem_prefix);

  for (const auto& param : parameters_) {
    const char* name = param->GetName();

    // Check subsystem prefix match (e.g., "audio.freq" starts with "audio")
    if (strncmp(name, subsystem_prefix, prefix_len) == 0 && name[prefix_len] == '.') {
      // Check visibility condition
      if (param->IsVisible(config)) {
        visible.push_back(param.get());
      }
    }
  }

  return visible;
}

std::string ParameterRegistry::ExportJsonSchema(const DeviceConfig& config) const {
  cJSON* root = cJSON_CreateObject();
  if (root == nullptr) {
    ESP_LOGE(TAG, "Failed to allocate JSON root for schema export");
    return "{\"parameters\":[]}";
  }

  cJSON* parameters = cJSON_AddArrayToObject(root, "parameters");
  if (parameters == nullptr) {
    ESP_LOGE(TAG, "Failed to allocate parameters array for schema export");
    cJSON_Delete(root);
    return "{\"parameters\":[]}";
  }

  for (const auto& param : parameters_) {
    if (!param->IsVisible(config)) {
      continue;
    }

    cJSON* param_obj = param->CreateJsonSchema();
    if (param_obj == nullptr) {
      ESP_LOGE(TAG, "Failed to create schema for parameter '%s'", param->GetName());
      continue;
    }

    cJSON_AddItemToArray(parameters, param_obj);
  }

  char* printed = cJSON_PrintUnformatted(root);
  if (printed == nullptr) {
    ESP_LOGE(TAG, "Failed to serialize parameter schema to JSON");
    cJSON_Delete(root);
    return "{\"parameters\":[]}";
  }

  std::string json(printed);
  cJSON_free(printed);
  cJSON_Delete(root);
  return json;
}

std::string ParameterRegistry::GenerateHelpText(const char* subsystem_prefix,
                                                 const DeviceConfig& config) const {
  std::vector<Parameter*> visible = GetVisibleParameters(subsystem_prefix, config);

  if (visible.empty()) {
    return std::string("No parameters available for subsystem '") + subsystem_prefix + "'\n";
  }

  // Capitalize subsystem name for header
  std::string header = subsystem_prefix;
  if (!header.empty()) {
    header[0] = static_cast<char>(toupper(header[0]));
  }
  header += " Parameters:\n";

  std::string help = header;

  for (Parameter* param : visible) {
    const char* full_name = param->GetName();
    const char* short_name = strchr(full_name, '.');
    if (short_name) {
      short_name++;  // Skip the '.'
    } else {
      short_name = full_name;
    }

    std::string current_value = param->GetCurrentValue(config);
    const char* type = param->GetTypeName();
    const char* desc = param->GetDescription();
    const char* unit = param->GetUnit();

    // Format: "  freq (int): Sidetone frequency [100-2000] Hz (current: 700)\n"
    help += "  ";
    help += short_name;
    help += " (";
    help += type;
    help += "): ";
    help += desc;

    // Add type-specific range info from metadata
    std::string range = param->GetRangeDescription();
    if (!range.empty()) {
      help += " [";
      help += range;
      help += "]";
    }

    if (unit && strlen(unit) > 0) {
      help += " ";
      help += unit;
    }

    help += " (current: ";
    help += current_value;
    help += ")\n";
  }

  return help;
}

//
// Parameter registration
//
// NOTE: RegisterAllParameters() is now auto-generated from parameters.yaml
// See: components/config/parameter_registry_generated.cpp
// Generated by: components/config/scripts/generate_parameters.py
//
// This file now only contains the ParameterRegistry class implementation.
// Parameter registrations are handled by the auto-generated code.

}  // namespace config
