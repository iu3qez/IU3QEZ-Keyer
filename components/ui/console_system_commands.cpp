/**
 * @file console_system_commands.cpp
 * @brief System commands implementation for serial console
 */

#include "ui/console_system_commands.hpp"
#include "ui/serial_console.hpp"
#include "app/bootloader_entry.hpp"
#include "remote/remote_cw_client.hpp"
#include "remote/remote_cw_server.hpp"
#include "keying_subsystem/keying_subsystem.hpp"
#include "morse_decoder/morse_decoder.hpp"
#include "morse_decoder/adaptive_timing_classifier.hpp"
#include "system_monitor/system_monitor.hpp"
#include "esp_log.h"
#include "esp_system.h"
#include "esp_timer.h"
#include "nvs_flash.h"
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <inttypes.h>

// Include auto-generated logging tags list
// This file is generated by tools/generate_log_tags.py during build
#include "generated_log_tags.hpp"

namespace ui {

static const char* TAG = "console_system";

// External global console instance (defined in serial_console.cpp)
extern SerialConsole* g_console_instance;

// Global remote client instance (set by RemoteClientPhase via SetRemoteClient())
static remote::RemoteCwClient* g_remote_client = nullptr;

// Global remote server instance (set by RemoteServerPhase via SetRemoteServer())
static remote::RemoteCwServer* g_remote_server = nullptr;

// Global keying subsystem instance (set via SetKeyingSubsystem())
static keying_subsystem::KeyingSubsystem* g_keying_subsystem = nullptr;

// Global morse decoder instance (set via SetMorseDecoder())
static morse_decoder::MorseDecoder* g_morse_decoder = nullptr;

//=============================================================================
// Reboot Command
//=============================================================================

int HandleRebootCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "reboot: console instance is null");
        return -1;
    }

    if (args.size() > 2) {
        g_console_instance->Print("Usage: reboot [bootloader]\r\n");
        g_console_instance->Print("  reboot            - Restart the device\r\n");
        g_console_instance->Print("  reboot bootloader - Enter UF2 bootloader for USB firmware update\r\n");
        return -1;
    }

    // Check for bootloader argument
    if (args.size() == 2) {
        if (args[1] == "bootloader") {
            g_console_instance->Print("\r\nEntering UF2 bootloader mode...\r\n");
            g_console_instance->Print("Device will appear as USB drive 'KEYERBOOT'\r\n");
            g_console_instance->Print("Drag firmware.uf2 file to update\r\n\r\n");
            vTaskDelay(pdMS_TO_TICKS(100));  // Give time to send message

            app::EnterBootloaderMode();  // This function calls esp_restart() internally
            return 0;  // Never reached
        } else {
            g_console_instance->Printf("Error: Unknown option '%s'\r\n", args[1].c_str());
            g_console_instance->Print("Usage: reboot [bootloader]\r\n");
            return -1;
        }
    }

    // Normal reboot (no arguments)
    g_console_instance->Print("\r\nRebooting device...\r\n");
    vTaskDelay(pdMS_TO_TICKS(100));  // Give time to send message

    esp_restart();

    return 0;  // Never reached
}

//=============================================================================
// Tab Complete Handler for Reboot Command
//=============================================================================

std::vector<std::string> TabCompleteReboot(const std::string& input, size_t cursor_pos) {
    // Expected format: "reboot <partial>"
    // Extract the partial argument
    size_t first_space = input.find(' ');
    if (first_space == std::string::npos) {
        return {};  // No space, nothing to complete
    }

    std::string partial = input.substr(first_space + 1);

    // Available options
    std::vector<std::string> options = {"bootloader"};
    std::vector<std::string> matches;

    for (const auto& opt : options) {
        if (opt.find(partial) == 0) {  // Prefix match
            matches.push_back("reboot " + opt);  // Return full command
        }
    }

    return matches;
}

//=============================================================================
// Debug Command
//=============================================================================

int HandleDebugCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "debug: console instance is null");
        return -1;
    }

    // If no argument, show current level
    if (args.size() == 1) {
        g_console_instance->Print("Current log level: ");

        // Get current log level (check a known tag or use default)
        esp_log_level_t current = esp_log_level_get("*");

        switch (current) {
            case ESP_LOG_NONE:    g_console_instance->Print("none\r\n"); break;
            case ESP_LOG_ERROR:   g_console_instance->Print("error\r\n"); break;
            case ESP_LOG_WARN:    g_console_instance->Print("warn\r\n"); break;
            case ESP_LOG_INFO:    g_console_instance->Print("info\r\n"); break;
            case ESP_LOG_DEBUG:   g_console_instance->Print("debug\r\n"); break;
            case ESP_LOG_VERBOSE: g_console_instance->Print("verbose\r\n"); break;
            default:              g_console_instance->Print("unknown\r\n"); break;
        }

        g_console_instance->Print("\r\nAvailable levels: none, error, warn, info, debug, verbose\r\n");
        g_console_instance->Print("Subcommands:\r\n");
        g_console_instance->Print("  debug tags     - List all available logging tags\r\n");
        g_console_instance->Print("  debug timeline - Dump timeline hooks status\r\n");
        g_console_instance->Print("Usage:\r\n");
        g_console_instance->Print("  debug <level>       - Set global log level\r\n");
        g_console_instance->Print("  debug <tag> <level> - Set log level for specific tag\r\n");
        g_console_instance->Print("  debug tags          - Show all available tags\r\n");
        g_console_instance->Print("  debug timeline      - Dump timeline hooks status\r\n");
        g_console_instance->Print("\r\nExamples:\r\n");
        g_console_instance->Print("  debug debug                - Set global level to debug\r\n");
        g_console_instance->Print("  debug paddle_engine debug  - Set paddle_engine to debug\r\n");
        g_console_instance->Print("  debug tags                 - List all logging tags\r\n");
        return 0;
    }

    // Check for special subcommands
    std::string level_str = args[1];

    if (level_str == "timeline") {
        return HandleTimelineDebugCommand(args);
    }

    if (level_str == "tags") {
        // List all known logging tags
        g_console_instance->Print("\r\nKnown Logging Tags:\r\n");
        g_console_instance->Print("-------------------\r\n");

        for (size_t i = 0; i < KNOWN_LOG_TAGS_COUNT; i++) {
            g_console_instance->Printf("  %s\r\n", KNOWN_LOG_TAGS[i]);
        }

        g_console_instance->Printf("\r\nTotal: %zu tags\r\n", KNOWN_LOG_TAGS_COUNT);
        g_console_instance->Print("\r\nUsage:\r\n");
        g_console_instance->Print("  debug <tag> <level>  - Set log level for specific tag\r\n");
        g_console_instance->Print("  debug <level>        - Set global log level\r\n");
        g_console_instance->Print("\r\nExample:\r\n");
        g_console_instance->Print("  debug paddle_engine debug  - Enable debug logs for paddle_engine\r\n");
        g_console_instance->Print("  debug paddle_engine none   - Disable all logs for paddle_engine\r\n");

        return 0;
    }

    // Determine if we have tag-specific or global log level command
    // Format: debug <level>        -> global
    // Format: debug <tag> <level>  -> tag-specific
    std::string tag = "*";
    std::string level_arg;

    if (args.size() == 2) {
        // Global log level: debug <level>
        level_arg = args[1];
    } else if (args.size() == 3) {
        // Tag-specific: debug <tag> <level>
        tag = args[1];
        level_arg = args[2];
    } else {
        g_console_instance->Print("Error: Invalid number of arguments\r\n");
        g_console_instance->Print("Usage: debug <level> OR debug <tag> <level>\r\n");
        return -1;
    }

    // Parse log level
    esp_log_level_t new_level;

    if (level_arg == "none") {
        new_level = ESP_LOG_NONE;
    } else if (level_arg == "error") {
        new_level = ESP_LOG_ERROR;
    } else if (level_arg == "warn") {
        new_level = ESP_LOG_WARN;
    } else if (level_arg == "info") {
        new_level = ESP_LOG_INFO;
    } else if (level_arg == "debug") {
        new_level = ESP_LOG_DEBUG;
    } else if (level_arg == "verbose") {
        new_level = ESP_LOG_VERBOSE;
    } else {
        g_console_instance->Printf("Error: Unknown log level '%s'\r\n", level_arg.c_str());
        g_console_instance->Print("Available: none, error, warn, info, debug, verbose\r\n");
        return -1;
    }

    // Set log level for specified tag or all tags
    esp_log_level_set(tag.c_str(), new_level);

    if (tag == "*") {
        g_console_instance->Printf("Global log level set to: %s\r\n", level_arg.c_str());
    } else {
        g_console_instance->Printf("Log level for '%s' set to: %s\r\n", tag.c_str(), level_arg.c_str());
    }

    // Test the log level immediately
    if (tag == "*") {
        ESP_LOGD("test", "Test DEBUG log (global)");
        ESP_LOGI("test", "Test INFO log (global)");
    } else {
        ESP_LOGD(tag.c_str(), "Test DEBUG log for %s", tag.c_str());
        ESP_LOGI(tag.c_str(), "Test INFO log for %s", tag.c_str());
    }

    return 0;
}

//=============================================================================
// Tab Complete Handler for Debug Command
//=============================================================================

std::vector<std::string> TabCompleteDebug(const std::string& input, size_t cursor_pos) {
    // Expected formats:
    //   "debug <partial>"         -> complete with levels, special commands, or tags
    //   "debug <tag> <partial>"   -> complete with levels

    // Split input into tokens
    std::vector<std::string> tokens;
    size_t start = 0;
    size_t end = input.find(' ');

    while (end != std::string::npos) {
        if (end > start) {
            tokens.push_back(input.substr(start, end - start));
        }
        start = end + 1;
        end = input.find(' ', start);
    }
    if (start < input.length()) {
        tokens.push_back(input.substr(start));
    }

    // Available log levels
    static const std::vector<std::string> log_levels = {
        "none", "error", "warn", "info", "debug", "verbose"
    };

    // Special commands
    static const std::vector<std::string> special_commands = {
        "tags", "timeline"
    };

    std::vector<std::string> matches;

    if (tokens.size() <= 1) {
        // No arguments yet, return empty (should not happen as we're past first space)
        return matches;
    }

    if (tokens.size() == 2) {
        // First argument: complete with levels + special commands + tags
        std::string partial = tokens[1];

        // Match log levels
        for (const auto& level : log_levels) {
            if (level.find(partial) == 0) {
                matches.push_back("debug " + level);
            }
        }

        // Match special commands
        for (const auto& cmd : special_commands) {
            if (cmd.find(partial) == 0) {
                matches.push_back("debug " + cmd);
            }
        }

        // Match tags
        for (size_t i = 0; i < KNOWN_LOG_TAGS_COUNT; i++) {
            std::string tag = KNOWN_LOG_TAGS[i];
            if (tag.find(partial) == 0) {
                matches.push_back("debug " + tag + " ");  // Add trailing space for next arg
            }
        }

    } else if (tokens.size() == 3) {
        // Second argument: complete with log levels only
        std::string tag = tokens[1];
        std::string partial = tokens[2];

        // Verify that first token is a valid tag (not a level or special command)
        bool is_tag = false;
        for (size_t i = 0; i < KNOWN_LOG_TAGS_COUNT; i++) {
            if (tag == KNOWN_LOG_TAGS[i]) {
                is_tag = true;
                break;
            }
        }

        if (is_tag) {
            // Complete with log levels
            for (const auto& level : log_levels) {
                if (level.find(partial) == 0) {
                    matches.push_back("debug " + tag + " " + level);
                }
            }
        }
    }

    return matches;
}

//=============================================================================
// Factory Reset Command
//=============================================================================

int HandleFactoryResetCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "factory-reset: console instance is null");
        return -1;
    }

    // Require "confirm" argument to prevent accidental resets
    if (args.size() < 2 || args[1] != "confirm") {
        g_console_instance->Print("WARNING: This will erase ALL configuration and reboot!\r\n");
        g_console_instance->Print("\r\n");
        g_console_instance->Print("This action will:\r\n");
        g_console_instance->Print("  - Erase all NVS flash data\r\n");
        g_console_instance->Print("  - Reset to factory defaults\r\n");
        g_console_instance->Print("  - Reboot the device\r\n");
        g_console_instance->Print("\r\n");
        g_console_instance->Print("To proceed, type: factory-reset confirm\r\n");
        return -1;
    }

    g_console_instance->Print("\r\nErasing NVS flash...\r\n");

    // Erase NVS partition
    esp_err_t err = nvs_flash_erase();
    if (err != ESP_OK) {
        g_console_instance->Printf("Error erasing NVS: %s (0x%x)\r\n",
                                   esp_err_to_name(err), err);
        return -1;
    }

    g_console_instance->Print("NVS erased successfully!\r\n");
    g_console_instance->Print("Rebooting to factory defaults...\r\n");

    vTaskDelay(pdMS_TO_TICKS(500));  // Give time to send messages

    esp_restart();

    return 0;  // Never reached
}

//=============================================================================
// Remote Command
//=============================================================================

int HandleRemoteCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "remote: console instance is null");
        return -1;
    }

    // Check if remote client is available
    if (!g_remote_client) {
        g_console_instance->Print("Error: Remote client not initialized\r\n\r\n");
        g_console_instance->Print("To configure remote CW keying:\r\n");
        g_console_instance->Print("  1. Set server address: set remote.server_host <hostname/IP>\r\n");
        g_console_instance->Print("     Example: set remote.server_host cwserver.local\r\n");
        g_console_instance->Print("  2. Set server port:    set remote.server_port <port>\r\n");
        g_console_instance->Print("     Example: set remote.server_port 7355\r\n");
        g_console_instance->Print("  3. Enable remote:      set remote.enabled true\r\n");
        g_console_instance->Print("  4. Save config:        save\r\n");
        g_console_instance->Print("  5. Reboot device:      reboot\r\n");
        g_console_instance->Print("  6. Start connection:   remote start\r\n");
        return -1;
    }

    // If no subcommand, show usage
    if (args.size() < 2) {
        g_console_instance->Print("Remote CW Client Commands:\r\n");
        g_console_instance->Print("  remote start  - Start connection to remote server\r\n");
        g_console_instance->Print("  remote stop   - Stop connection and disable client\r\n");
        g_console_instance->Print("  remote status - Show connection status and statistics\r\n");
        g_console_instance->Print("  remote info   - Show task diagnostic information (for debugging)\r\n");
        return 0;
    }

    std::string subcmd = args[1];

    if (subcmd == "start") {
        // Start remote client connection
        esp_err_t err = g_remote_client->Start();
        if (err != ESP_OK) {
            g_console_instance->Printf("Error starting remote client: %s\r\n", esp_err_to_name(err));
            return -1;
        }
        g_console_instance->Print("Remote client started (connecting...)\r\n");
        return 0;
    }
    else if (subcmd == "stop") {
        // Stop remote client
        g_remote_client->Stop();
        g_console_instance->Print("Remote client stopped\r\n");
        return 0;
    }
    else if (subcmd == "status") {
        // Display connection status
        remote::RemoteCwClientState state = g_remote_client->GetState();
        uint32_t latency_ms = g_remote_client->GetLatency();

        g_console_instance->Print("\r\nRemote CW Client Status:\r\n");
        g_console_instance->Print("------------------------\r\n");

        // Connection state
        g_console_instance->Print("State:   ");
        switch (state) {
            case remote::RemoteCwClientState::kIdle:
                g_console_instance->Print("Idle (not connected)\r\n");
                break;
            case remote::RemoteCwClientState::kResolving:
                g_console_instance->Print("Resolving hostname...\r\n");
                break;
            case remote::RemoteCwClientState::kConnecting:
                g_console_instance->Print("Connecting to server...\r\n");
                break;
            case remote::RemoteCwClientState::kHandshake:
                g_console_instance->Print("Handshake in progress...\r\n");
                break;
            case remote::RemoteCwClientState::kConnected:
                g_console_instance->Print("Connected\r\n");
                break;
            case remote::RemoteCwClientState::kError:
                g_console_instance->Print("Error (will retry if auto_reconnect enabled)\r\n");
                break;
            default:
                g_console_instance->Print("Unknown\r\n");
                break;
        }

        // Latency (only if connected)
        if (state == remote::RemoteCwClientState::kConnected) {
            if (latency_ms > 0) {
                g_console_instance->Printf("Latency: %lu ms (round-trip)\r\n",
                                         static_cast<unsigned long>(latency_ms));
            } else {
                g_console_instance->Print("Latency: Measuring...\r\n");
            }
        }

        g_console_instance->Print("\r\n");
        return 0;
    }
    else if (subcmd == "info") {
        // Dump task diagnostics
        g_console_instance->Print("\r\nTask diagnostic information:\r\n");
        g_remote_client->DumpDiagnostics();
        g_console_instance->Print("(See log output above)\r\n\r\n");
        return 0;
    }
    else {
        g_console_instance->Printf("Error: Unknown subcommand '%s'\r\n", subcmd.c_str());
        g_console_instance->Print("Available: start, stop, status, info\r\n");
        return -1;
    }
}

//=============================================================================
// Server Command
//=============================================================================

int HandleServerCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "server: console instance is null");
        return -1;
    }

    // Check if server is available
    if (!g_remote_server) {
        g_console_instance->Print("Error: Remote server not initialized\r\n");
        g_console_instance->Print("Enable server with: server enabled true\r\n");
        return -1;
    }

    // If no subcommand, show usage
    if (args.size() < 2) {
        g_console_instance->Print("Remote CW Server Commands:\r\n");
        g_console_instance->Print("  server start  - Start listening for client connections\r\n");
        g_console_instance->Print("  server stop   - Stop server and close connections\r\n");
        g_console_instance->Print("  server status - Show server state and client info\r\n");
        return 0;
    }

    std::string subcmd = args[1];

    if (subcmd == "start") {
        // Start server
        esp_err_t err = g_remote_server->Start();
        if (err != ESP_OK) {
            g_console_instance->Printf("Error starting server: %s\r\n", esp_err_to_name(err));
            return -1;
        }
        g_console_instance->Print("Server started (listening for connections...)\r\n");
        return 0;
    }
    else if (subcmd == "stop") {
        // Stop server
        g_remote_server->Stop();
        g_console_instance->Print("Server stopped\r\n");
        return 0;
    }
    else if (subcmd == "status") {
        // Display server status
        remote::RemoteCwServerState state = g_remote_server->state();

        g_console_instance->Print("\r\nRemote CW Server Status:\r\n");
        g_console_instance->Print("------------------------\r\n");

        // Server state
        g_console_instance->Print("State:   ");
        switch (state) {
            case remote::RemoteCwServerState::kIdle:
                g_console_instance->Print("Idle (not listening)\r\n");
                break;
            case remote::RemoteCwServerState::kListening:
                g_console_instance->Print("Listening (waiting for client)\r\n");
                break;
            case remote::RemoteCwServerState::kHandshake:
                g_console_instance->Print("Client connected (handshake in progress)\r\n");
                break;
            case remote::RemoteCwServerState::kConnected:
                g_console_instance->Print("Client connected (receiving keying)\r\n");
                break;
            case remote::RemoteCwServerState::kError:
                g_console_instance->Print("Error (will restart if auto_restart enabled)\r\n");
                break;
            default:
                g_console_instance->Print("Unknown\r\n");
                break;
        }

        g_console_instance->Print("\r\n");
        return 0;
    }
    else {
        g_console_instance->Printf("Error: Unknown subcommand '%s'\r\n", subcmd.c_str());
        g_console_instance->Print("Available: start, stop, status\r\n");
        return -1;
    }
}

//=============================================================================
// Remote Client/Server Setters
//=============================================================================

void SetRemoteClient(remote::RemoteCwClient* client) {
    g_remote_client = client;
    if (client) {
        ESP_LOGI(TAG, "Remote client registered with console commands");
    }
}

void SetRemoteServer(remote::RemoteCwServer* server) {
    g_remote_server = server;
    if (server) {
        ESP_LOGI(TAG, "Remote server registered with console commands");
    }
}

void SetKeyingSubsystem(keying_subsystem::KeyingSubsystem* keying) {
    g_keying_subsystem = keying;
    if (keying) {
        ESP_LOGI(TAG, "Keying subsystem registered with console debug commands");
    }
}

void SetMorseDecoder(morse_decoder::MorseDecoder* decoder) {
    g_morse_decoder = decoder;
    if (decoder) {
        ESP_LOGI(TAG, "Morse decoder registered with console commands");
    }
}

//=============================================================================
// Keying Debug Command
//=============================================================================

int HandleKeyingDebugCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "keying-debug: console instance is null");
        return -1;
    }

    if (!g_keying_subsystem) {
        g_console_instance->Print("Error: Keying subsystem not initialized\r\n");
        return -1;
    }

    if (args.size() > 1) {
        g_console_instance->Print("Usage: keying-debug\r\n");
        g_console_instance->Print("Dumps complete paddle engine state for debugging lockups\r\n");
        return -1;
    }

    g_console_instance->Print("Dumping paddle engine state...\r\n");

    // Get current timestamp and dump state
    const int64_t now_us = esp_timer_get_time();
    g_keying_subsystem->DumpEngineState(now_us);

    g_console_instance->Print("State dump complete (check log output)\r\n");
    return 0;
}

//=============================================================================
// Timeline Debug Command
//=============================================================================

int HandleTimelineDebugCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "debug timeline: console instance is null");
        return -1;
    }

    if (!g_keying_subsystem) {
        g_console_instance->Print("Error: Keying subsystem not initialized\r\n");
        return -1;
    }

    if (args.size() > 2) {
        g_console_instance->Print("Usage: debug timeline\r\n");
        g_console_instance->Print("Dumps timeline hooks status for LOGIC overlay diagnostics\r\n");
        return -1;
    }

    g_console_instance->Print("Dumping timeline hooks status...\r\n");

    // Call keying subsystem to dump hooks state
    g_keying_subsystem->DumpTimelineHooksStatus();

    g_console_instance->Print("Timeline hooks dump complete (check log output)\r\n");
    return 0;
}

//=============================================================================
// Decoder Command
//=============================================================================

int HandleDecoderCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "decoder: console instance is null");
        return -1;
    }

    // Check if decoder is initialized
    if (!g_morse_decoder) {
        g_console_instance->Print("Error: Morse decoder not initialized\r\n");
        return -1;
    }

    // If no subcommand, show usage
    if (args.size() < 2) {
        g_console_instance->Print("Morse Decoder Commands:\r\n");
        g_console_instance->Print("  decoder start  - Enable decoder (keying → text)\r\n");
        g_console_instance->Print("  decoder stop   - Disable decoder\r\n");
        g_console_instance->Print("  decoder reset  - Clear buffer and reset timing\r\n");
        g_console_instance->Print("  decoder stats  - Show timing statistics\r\n");
        g_console_instance->Print("  decoder text   - Display decoded text buffer\r\n");
        return 0;
    }

    std::string subcmd = args[1];

    if (subcmd == "start") {
        g_morse_decoder->SetEnabled(true);
        g_console_instance->Print("Decoder enabled\r\n");
        return 0;
    }
    else if (subcmd == "stop") {
        g_morse_decoder->SetEnabled(false);
        g_console_instance->Print("Decoder disabled\r\n");
        return 0;
    }
    else if (subcmd == "reset") {
        g_morse_decoder->Reset();
        g_console_instance->Print("Decoder reset (buffer cleared, timing reset)\r\n");
        return 0;
    }
    else if (subcmd == "stats") {
        // Get timing stats from keying subsystem's timing classifier
        if (!g_keying_subsystem) {
            g_console_instance->Print("Error: Keying subsystem not initialized\r\n");
            return -1;
        }

        auto* classifier = g_keying_subsystem->GetTimingClassifier();
        if (!classifier) {
            g_console_instance->Print("Error: Timing classifier not initialized\r\n");
            return -1;
        }

        auto stats = classifier->GetTimingStats();
        uint32_t wpm = g_morse_decoder->GetDetectedWPM();

        g_console_instance->Print("\r\n=== Morse Decoder Statistics ===\r\n");
        g_console_instance->Printf("Detected WPM:   %u\r\n", wpm);
        g_console_instance->Printf("Dit average:    %" PRId64 " μs\r\n", stats.avg_dit_us);
        g_console_instance->Printf("Dah average:    %" PRId64 " μs\r\n", stats.avg_dah_us);
        g_console_instance->Printf("Dah/Dit ratio:  %.2f:1\r\n", stats.ratio);
        g_console_instance->Printf("Dit samples:    %u\r\n", stats.dit_sample_count);
        g_console_instance->Printf("Dah samples:    %u\r\n", stats.dah_sample_count);
        g_console_instance->Printf("Decoder state:  %s\r\n",
                                  g_morse_decoder->IsEnabled() ? "Enabled" : "Disabled");

        std::string pattern = g_morse_decoder->GetCurrentPattern();
        if (!pattern.empty()) {
            g_console_instance->Printf("Current pattern: '%s'\r\n", pattern.c_str());
        } else {
            g_console_instance->Print("Current pattern: (none)\r\n");
        }

        g_console_instance->Print("================================\r\n\r\n");
        return 0;
    }
    else if (subcmd == "text") {
        std::string decoded = g_morse_decoder->GetDecodedText();

        g_console_instance->Print("\r\n=== Decoded Text Buffer ===\r\n");
        if (decoded.empty()) {
            g_console_instance->Print("(buffer empty)\r\n");
        } else {
            g_console_instance->Print("\"");
            g_console_instance->Print(decoded.c_str());
            g_console_instance->Print("\"\r\n");
            g_console_instance->Printf("Length: %zu characters\r\n", decoded.length());
        }
        g_console_instance->Print("===========================\r\n\r\n");
        return 0;
    }
    else {
        g_console_instance->Printf("Error: Unknown subcommand '%s'\r\n", subcmd.c_str());
        g_console_instance->Print("Available: start, stop, reset, stats, text\r\n");
        return -1;
    }
}

//=============================================================================
// CPU Command
//=============================================================================

int HandleCpuCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "cpu: console instance is null");
        return -1;
    }

    if (args.size() > 1) {
        g_console_instance->Print("Usage: cpu\r\n");
        g_console_instance->Print("Display CPU usage statistics per task\r\n");
        return -1;
    }

    system_monitor::SystemMonitor monitor;

    // Display uptime
    auto uptime = monitor.GetUptimeInfo();
    char uptime_buf[128];
    snprintf(uptime_buf, sizeof(uptime_buf),
             "\r\nSystem Uptime: %lu hours, %lu minutes, %lu seconds\r\n\r\n",
             uptime.uptime_hours, uptime.uptime_minutes % 60, uptime.uptime_seconds % 60);
    g_console_instance->Print(uptime_buf);

    // Display CPU stats
    std::string cpu_stats = monitor.GetCpuStatsFormatted();
    g_console_instance->Print(cpu_stats.c_str());
    g_console_instance->Print("\r\n");

    return 0;
}

//=============================================================================
// Tasks Command
//=============================================================================

int HandleTasksCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "tasks: console instance is null");
        return -1;
    }

    if (args.size() > 1) {
        g_console_instance->Print("Usage: tasks\r\n");
        g_console_instance->Print("Display task list with state, priority, and stack info\r\n");
        return -1;
    }

    system_monitor::SystemMonitor monitor;

    // Display heap info
    auto heap = monitor.GetHeapInfo();
    char heap_buf[256];
    snprintf(heap_buf, sizeof(heap_buf),
             "\r\nHeap Memory:\r\n"
             "  Free:          %lu bytes\r\n"
             "  Minimum Free:  %lu bytes\r\n"
             "  Total:         %lu bytes\r\n"
             "  Largest Block: %lu bytes\r\n\r\n",
             heap.free_bytes, heap.minimum_free_bytes,
             heap.total_bytes, heap.largest_free_block);
    g_console_instance->Print(heap_buf);

    // Display task list
    std::string task_list = monitor.GetTaskListFormatted();
    g_console_instance->Print(task_list.c_str());
    g_console_instance->Print("\r\n");

    return 0;
}

//=============================================================================
// System Command
//=============================================================================

int HandleSystemCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "system: console instance is null");
        return -1;
    }

    if (args.size() > 1) {
        g_console_instance->Print("Usage: system\r\n");
        g_console_instance->Print("Display complete system statistics in JSON format\r\n");
        return -1;
    }

    system_monitor::SystemMonitor monitor;

    g_console_instance->Print("\r\n");
    std::string json = monitor.GetSystemStatsJson();
    g_console_instance->Print(json.c_str());
    g_console_instance->Print("\r\n");

    return 0;
}

//=============================================================================
// Upgrade Command (Enter UF2 Bootloader Mode)
//=============================================================================

int HandleUpgradeCommand(const std::vector<std::string>& args) {
    if (!g_console_instance) {
        ESP_LOGE(TAG, "upgrade: console instance is null");
        return -1;
    }

    if (args.size() > 1) {
        g_console_instance->Print("Usage: upgrade\r\n");
        g_console_instance->Print("  Enters UF2 bootloader mode for USB firmware updates\r\n");
        return -1;
    }

    g_console_instance->Print("\r\n");
    g_console_instance->Print("╔══════════════════════════════════════════════════════════╗\r\n");
    g_console_instance->Print("║         ENTERING UF2 BOOTLOADER MODE                     ║\r\n");
    g_console_instance->Print("╠══════════════════════════════════════════════════════════╣\r\n");
    g_console_instance->Print("║ Device will restart into USB mass storage mode           ║\r\n");
    g_console_instance->Print("║                                                          ║\r\n");
    g_console_instance->Print("║ Steps to update firmware:                                ║\r\n");
    g_console_instance->Print("║   1. Device will appear as USB drive 'KEYERBOOT'         ║\r\n");
    g_console_instance->Print("║   2. Drag firmware.uf2 file onto the drive               ║\r\n");
    g_console_instance->Print("║   3. Device will auto-reset with new firmware            ║\r\n");
    g_console_instance->Print("║                                                          ║\r\n");
    g_console_instance->Print("║ Your configuration will be preserved (NVS unchanged)     ║\r\n");
    g_console_instance->Print("╚══════════════════════════════════════════════════════════╝\r\n");
    g_console_instance->Print("\r\n");
    g_console_instance->Print("Restarting in 2 seconds...\r\n");

    // Give time for message to be displayed
    vTaskDelay(pdMS_TO_TICKS(2000));

    // Enter bootloader mode (never returns)
    app::EnterBootloaderMode();

    // Never reached
    return 0;
}

//=============================================================================
// Command Registration
//=============================================================================

void RegisterSystemCommands(SerialConsole* console) {
    if (!console) {
        ESP_LOGE(TAG, "RegisterSystemCommands: console is null");
        return;
    }

    // Register 'upgrade' command
    console->RegisterCommand("upgrade",
        [](const std::vector<std::string>& args) -> int {
            return HandleUpgradeCommand(args);
        },
        "upgrade - Enter UF2 bootloader mode for USB firmware updates");

    // Register 'reboot' command
    console->RegisterCommand("reboot",
        [](const std::vector<std::string>& args) -> int {
            return HandleRebootCommand(args);
        },
        "reboot [bootloader] - Restart the device or enter UF2 bootloader mode",
        [](const std::string& input, size_t cursor_pos) -> std::vector<std::string> {
            return TabCompleteReboot(input, cursor_pos);
        });

    // Register 'debug' command
    console->RegisterCommand("debug",
        [](const std::vector<std::string>& args) -> int {
            return HandleDebugCommand(args);
        },
        "debug [level|tag] - Set ESP-IDF log level or show tags/timeline",
        [](const std::string& input, size_t cursor_pos) -> std::vector<std::string> {
            return TabCompleteDebug(input, cursor_pos);
        });

    // Register 'factory-reset' command
    console->RegisterCommand("factory-reset",
        [](const std::vector<std::string>& args) -> int {
            return HandleFactoryResetCommand(args);
        },
        "factory-reset confirm - Erase NVS and restore factory defaults");

    // Register 'remote' command
    console->RegisterCommand("remote",
        [](const std::vector<std::string>& args) -> int {
            return HandleRemoteCommand(args);
        },
        "remote [start|stop|status] - Control remote CW client");

    // Register 'server' command
    console->RegisterCommand("server",
        [](const std::vector<std::string>& args) -> int {
            return HandleServerCommand(args);
        },
        "server [start|stop|status] - Control remote CW server");

    // Register 'keying-debug' command
    console->RegisterCommand("keying-debug",
        [](const std::vector<std::string>& args) -> int {
            return HandleKeyingDebugCommand(args);
        },
        "keying-debug - Dump paddle engine state for debugging");

    // Register 'decoder' command
    console->RegisterCommand("decoder",
        [](const std::vector<std::string>& args) -> int {
            return HandleDecoderCommand(args);
        },
        "decoder [start|stop|reset|stats|text] - Control morse code decoder");

    // Register 'cpu' command
    console->RegisterCommand("cpu",
        [](const std::vector<std::string>& args) -> int {
            return HandleCpuCommand(args);
        },
        "cpu - Display CPU usage statistics per task");

    // Register 'tasks' command
    console->RegisterCommand("tasks",
        [](const std::vector<std::string>& args) -> int {
            return HandleTasksCommand(args);
        },
        "tasks - Display task list with state, priority, and stack info");

    // Register 'system' command
    console->RegisterCommand("system",
        [](const std::vector<std::string>& args) -> int {
            return HandleSystemCommand(args);
        },
        "system - Display complete system statistics in JSON format");

    ESP_LOGI(TAG, "Registered system commands: reboot, debug, factory-reset, remote, server, keying-debug, decoder, cpu, tasks, system");
}

}  // namespace ui
